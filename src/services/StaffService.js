import instance from "./customize-axios";

/**
 * STAFF SERVICE - Frontend API Integration for Staff Operations
 * 
 * Service n√†y x·ª≠ l√Ω t·∫•t c·∫£ API calls cho staff/admin operations:
 * - Qu·∫£n l√Ω booking (xem, filter, c·∫≠p nh·∫≠t status)
 * - L·∫•y m·∫´u x√©t nghi·ªám (SampleCollectionForm)
 * - Upload k·∫øt qu·∫£ x√©t nghi·ªám (TestResultForm)
 * - Qu·∫£n l√Ω testing services
 * - Dashboard statistics
 * 
 * Backend Integration:
 * - BE-SWP391/src/main/java/com/example/gender_healthcare_service/controller/BookingController.java
 * - BE-SWP391/src/main/java/com/example/gender_healthcare_service/controller/ServiceController.java
 * - BE-SWP391/src/main/java/com/example/gender_healthcare_service/controller/AdminController.java
 * 
 * Workflow Integration:
 * - Staff l·∫•y m·∫´u: CONFIRMED ‚Üí SAMPLE_COLLECTED
 * - Staff upload k·∫øt qu·∫£: SAMPLE_COLLECTED ‚Üí COMPLETED
 * - WebSocket notifications cho customer real-time updates
 */

// =============Staff Booking Management APIs============

/**
 * L·∫•y t·∫•t c·∫£ booking cho staff qu·∫£n l√Ω
 * 
 * Frontend: SWP391_FE/src/pages/Staff/StaffAppointments.jsx
 * - Staff xem danh s√°ch t·∫•t c·∫£ booking ƒë·ªÉ qu·∫£n l√Ω
 * - C√≥ th·ªÉ filter theo status, customer, service, date range
 * - Hi·ªÉn th·ªã booking theo t·ª´ng status: PENDING, CONFIRMED, SAMPLE_COLLECTED, COMPLETED
 * - G·ªçi API GET /api/bookings/all v·ªõi pagination
 * 
 * @param status Filter theo status (optional)
 * @param date Filter theo date (optional)
 * @returns Promise v·ªõi danh s√°ch booking
 */
const getAllBookingsAPI = async (status = null, date = null) => {
  try {
    let url = '/api/bookings/all';
    const params = new URLSearchParams();
    
    if (status) params.append('status', status);
    if (date) params.append('date', date);
    
    if (params.toString()) {
      url += `?${params.toString()}`;
    }
    
    const response = await instance.get(url);
    console.log('Get all bookings success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Get all bookings error:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * L·∫•y booking theo status c·ª• th·ªÉ
 * 
 * Frontend: SWP391_FE/src/pages/Staff/StaffAppointments.jsx
 * - Staff c√≥ th·ªÉ xem booking theo t·ª´ng status ri√™ng bi·ªát
 * - V√≠ d·ª•: xem t·∫•t c·∫£ booking PENDING ƒë·ªÉ x√°c nh·∫≠n
 * - Xem t·∫•t c·∫£ booking SAMPLE_COLLECTED ƒë·ªÉ upload k·∫øt qu·∫£
 * - G·ªçi API GET /api/bookings/status/{status}
 * 
 * @param status Status c·∫ßn filter (PENDING, CONFIRMED, SAMPLE_COLLECTED, COMPLETED)
 * @param pageNumber S·ªë trang (default: 1)
 * @param pageSize S·ªë booking m·ªói trang (default: 100)
 * @returns Promise v·ªõi danh s√°ch booking theo status
 */
const getBookingsByStatusAPI = async (status, pageNumber = 1, pageSize = 100) => {
  try {
    const response = await instance.get(`/api/bookings/status/${status}`, {
      params: { pageNumber, pageSize }
    });
    console.log('Get bookings by status success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Get bookings by status error:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * L·∫•y chi ti·∫øt booking theo ID
 * 
 * Frontend: SWP391_FE/src/pages/Staff/StaffAppointments.jsx
 * - Staff click v√†o booking ƒë·ªÉ xem chi ti·∫øt
 * - Hi·ªÉn th·ªã th√¥ng tin ƒë·∫ßy ƒë·ªß: customer, service, timeslot, status
 * - G·ªçi API GET /api/bookings/{bookingId}/admin
 * 
 * @param bookingId ID c·ªßa booking c·∫ßn xem
 * @returns Promise v·ªõi th√¥ng tin chi ti·∫øt booking
 */
const getBookingByIdAPI = async (bookingId) => {
  try {
    const response = await instance.get(`/api/bookings/${bookingId}/admin`);
    console.log('Get booking by ID success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Get booking by ID error:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i booking
 * 
 * Frontend: SWP391_FE/src/pages/Staff/StaffAppointments.jsx
 * - Staff c√≥ th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i booking (CONFIRMED, SAMPLE_COLLECTED, COMPLETED)
 * - G·ªçi API PATCH /api/bookings/{bookingId}/status
 * - Trigger WebSocket notification ƒë·∫øn customer tracking page
 * 
 * @param bookingId ID c·ªßa booking c·∫ßn c·∫≠p nh·∫≠t
 * @param status Status m·ªõi
 * @returns Promise v·ªõi booking ƒë√£ c·∫≠p nh·∫≠t
 */
const updateBookingStatusAPI = async (bookingId, status) => {
  try {
    const response = await instance.patch(`/api/bookings/${bookingId}/status`, {
      status: status
    });
    console.log('Update booking status success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Update booking status error:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * WORKFLOW STEP 3: Staff l·∫•y m·∫´u x√©t nghi·ªám v√† nh·∫≠p t√™n b√°c sƒ© ph·ª• tr√°ch
 * 
 * Frontend: SWP391_FE/src/components/staff/SampleCollectionForm.jsx
 * - Staff ƒëi·ªÅn th√¥ng tin ng∆∞·ªùi l·∫•y m·∫´u v√† t√™n b√°c sƒ© ph·ª• tr√°ch
 * - G·ªçi API POST /api/bookings/{bookingId}/sample-collection
 * - T·∫°o SampleCollectionProfile v·ªõi doctorName field
 * - Chuy·ªÉn status t·ª´ CONFIRMED ‚Üí SAMPLE_COLLECTED
 * - Trigger WebSocket notification: CONFIRMED ‚Üí SAMPLE_COLLECTED
 * - Customer nh·∫≠n ƒë∆∞·ª£c real-time update v·ªÅ vi·ªác ƒë√£ l·∫•y m·∫´u
 * 
 * @param bookingId ID c·ªßa booking c·∫ßn l·∫•y m·∫´u
 * @param sampleData Th√¥ng tin ng∆∞·ªùi l·∫•y m·∫´u v√† doctorName
 * @returns Promise v·ªõi booking ƒë√£ c·∫≠p nh·∫≠t
 */
const markSampleCollectedAPI = async (bookingId, sampleData) => {
  try {
    const response = await instance.post(`/api/bookings/${bookingId}/sample-collection`, sampleData);
    console.log('Mark sample collected success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Mark sample collected error:', error.response?.data || error.message);
    throw error;
  }
};

// =============Staff Results Management APIs============

/**
 * WORKFLOW STEP 4: Staff upload k·∫øt qu·∫£ x√©t nghi·ªám
 * 
 * Frontend: SWP391_FE/src/components/staff/TestResultForm.jsx
 * - Staff nh·∫≠p k·∫øt qu·∫£ x√©t nghi·ªám chi ti·∫øt
 * - G·ªçi API POST /api/services/testing-services/bookings/{bookingId}/results
 * - T·ª± ƒë·ªông chuy·ªÉn status t·ª´ SAMPLE_COLLECTED ‚Üí COMPLETED
 * - Trigger WebSocket notification ƒë·∫øn customer tracking page
 * - Customer nh·∫≠n ƒë∆∞·ª£c real-time update v√† c√≥ th·ªÉ xem k·∫øt qu·∫£ ngay
 * 
 * @param bookingId ID c·ªßa booking c·∫ßn c·∫≠p nh·∫≠t k·∫øt qu·∫£
 * @param resultData {result, resultType, notes, resultDate}
 * @returns Promise v·ªõi booking ƒë√£ c·∫≠p nh·∫≠t
 */
const uploadTestResultAPI = async (bookingId, resultData) => {
  try {
    const response = await instance.post(`/api/services/testing-services/bookings/${bookingId}/results`, resultData);
    console.log('Upload test result success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Upload test result error:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * L·∫•y k·∫øt qu·∫£ x√©t nghi·ªám c·ªßa booking
 * 
 * Frontend: SWP391_FE/src/components/staff/TestResultForm.jsx
 * - Staff c√≥ th·ªÉ xem k·∫øt qu·∫£ ƒë√£ upload tr∆∞·ªõc ƒë√≥
 * - G·ªçi API GET /api/services/testing-services/bookings/{bookingId}/results
 * - Hi·ªÉn th·ªã k·∫øt qu·∫£ trong form ƒë·ªÉ ch·ªânh s·ª≠a
 * 
 * @param bookingId ID c·ªßa booking c·∫ßn xem k·∫øt qu·∫£
 * @returns Promise v·ªõi th√¥ng tin k·∫øt qu·∫£
 */
const getTestResultAPI = async (bookingId) => {
  try {
    const response = await instance.get(`/api/services/testing-services/bookings/${bookingId}/results`);
    console.log('Get test result success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Get test result error:', error.response?.data || error.message);
    throw error;
  }
};

// =============Staff Service Management APIs============

/**
 * L·∫•y t·∫•t c·∫£ testing services
 * 
 * Frontend: SWP391_FE/src/pages/Staff/StaffUploadResult.jsx
 * - Staff xem danh s√°ch c√°c d·ªãch v·ª• x√©t nghi·ªám c√≥ s·∫µn
 * - G·ªçi API GET /api/staff/testing-services
 * - Hi·ªÉn th·ªã t√™n service, m√¥ t·∫£, gi√°, th·ªùi gian x·ª≠ l√Ω
 * 
 * @returns Promise v·ªõi danh s√°ch testing services
 */
const getAllTestingServicesAPI = async () => {
  try {
    console.log('üöÄ Calling API: /api/staff/testing-services');
    const response = await instance.get('/api/staff/testing-services');
    console.log('‚úÖ Get all testing services success:', response.data);
    return response.data;
  } catch (error) {
    console.error('‚ùå Get all testing services error:', error.response?.data || error.message);
    console.error('‚ùå Full error:', error);
    throw error;
  }
};

/**
 * T·∫°o testing service m·ªõi
 * 
 * Frontend: SWP391_FE/src/pages/admin/AdminTestingServices.jsx
 * - Admin t·∫°o d·ªãch v·ª• x√©t nghi·ªám m·ªõi
 * - G·ªçi API POST /api/staff/testing-services
 * - L∆∞u th√¥ng tin: t√™n, m√¥ t·∫£, gi√°, th·ªùi gian x·ª≠ l√Ω
 * 
 * @param serviceData Th√¥ng tin service m·ªõi
 * @returns Promise v·ªõi service ƒë√£ t·∫°o
 */
const createTestingServiceAPI = async (serviceData) => {
  try {
    const response = await instance.post('/api/staff/testing-services', serviceData);
    console.log('Create testing service success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Create testing service error:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t testing service
 * 
 * Frontend: SWP391_FE/src/pages/admin/AdminTestingServices.jsx
 * - Admin ch·ªânh s·ª≠a th√¥ng tin d·ªãch v·ª• x√©t nghi·ªám
 * - G·ªçi API PATCH /api/staff/testing-services/{serviceId}
 * - C·∫≠p nh·∫≠t: t√™n, m√¥ t·∫£, gi√°, th·ªùi gian x·ª≠ l√Ω
 * 
 * @param serviceId ID c·ªßa service c·∫ßn c·∫≠p nh·∫≠t
 * @param serviceData Th√¥ng tin service m·ªõi
 * @returns Promise v·ªõi service ƒë√£ c·∫≠p nh·∫≠t
 */
const updateTestingServiceAPI = async (serviceId, serviceData) => {
  try {
    const response = await instance.patch(`/api/staff/testing-services/${serviceId}`, serviceData);
    console.log('Update testing service success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Update testing service error:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * X√≥a testing service
 * 
 * Frontend: SWP391_FE/src/pages/admin/AdminTestingServices.jsx
 * - Admin x√≥a d·ªãch v·ª• x√©t nghi·ªám (soft delete)
 * - G·ªçi API DELETE /api/staff/testing-services/{serviceId}
 * - Service kh√¥ng c√≤n hi·ªÉn th·ªã cho customer nh∆∞ng v·∫´n trong database
 * 
 * @param serviceId ID c·ªßa service c·∫ßn x√≥a
 * @returns Promise v·ªõi th√¥ng b√°o th√†nh c√¥ng
 */
const deleteTestingServiceAPI = async (serviceId) => {
  try {
    const response = await instance.delete(`/api/staff/testing-services/${serviceId}`);
    console.log('Delete testing service success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Delete testing service error:', error.response?.data || error.message);
    throw error;
  }
};

// =============Staff Dashboard APIs============

/**
 * L·∫•y th·ªëng k√™ dashboard cho staff
 * 
 * Frontend: SWP391_FE/src/pages/Staff/StaffDashboard.jsx
 * - Hi·ªÉn th·ªã t·ªïng s·ªë booking, booking theo status
 * - Hi·ªÉn th·ªã s·ªë booking theo ng√†y/tu·∫ßn/th√°ng
 * - G·ªçi API GET /api/staff/dashboard/stats
 * 
 * @returns Promise v·ªõi th·ªëng k√™ dashboard
 */
const getStaffDashboardStatsAPI = async () => {
  try {
    const response = await instance.get('/api/staff/dashboard/stats');
    console.log('Get staff dashboard stats success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Get staff dashboard stats error:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * L·∫•y booking theo kho·∫£ng th·ªùi gian
 * 
 * Frontend: SWP391_FE/src/pages/Staff/StaffDashboard.jsx
 * - Staff c√≥ th·ªÉ xem booking trong m·ªôt kho·∫£ng th·ªùi gian
 * - H·ªØu √≠ch ƒë·ªÉ l·∫≠p b√°o c√°o theo ng√†y/tu·∫ßn/th√°ng
 * - G·ªçi API GET /api/staff/bookings/date-range
 * 
 * @param startDate Ng√†y b·∫Øt ƒë·∫ßu
 * @param endDate Ng√†y k·∫øt th√∫c
 * @returns Promise v·ªõi danh s√°ch booking trong kho·∫£ng th·ªùi gian
 */
const getBookingsByDateRangeAPI = async (startDate, endDate) => {
  try {
    const response = await instance.get('/api/staff/bookings/date-range', {
      params: { startDate, endDate }
    });
    console.log('Get bookings by date range success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Get bookings by date range error:', error.response?.data || error.message);
    throw error;
  }
};

// =============Staff Service Class============

/**
 * StaffService Class - Wrapper cho t·∫•t c·∫£ staff APIs
 * 
 * Cung c·∫•p interface ƒë∆°n gi·∫£n cho frontend components ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi backend
 * T·ª± ƒë·ªông x·ª≠ l√Ω error handling v√† response formatting
 * T·∫≠p trung v√†o c√°c operations c·ªßa staff: qu·∫£n l√Ω booking, upload k·∫øt qu·∫£, th·ªëng k√™
 */
class StaffService {
  /**
   * L·∫•y t·∫•t c·∫£ booking cho staff qu·∫£n l√Ω
   * 
   * @param status Filter theo status (optional)
   * @param date Filter theo date (optional)
   * @returns {success: boolean, data: BookingResponseDTO[], message: string}
   */
  async getAllBookings(status, date) {
    try {
      const data = await getAllBookingsAPI(status, date);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * L·∫•y booking theo status c·ª• th·ªÉ
   * 
   * @param status Status c·∫ßn filter (PENDING, CONFIRMED, SAMPLE_COLLECTED, COMPLETED)
   * @param pageNumber S·ªë trang (default: 1)
   * @param pageSize S·ªë booking m·ªói trang (default: 100)
   * @returns {success: boolean, data: BookingResponseDTO[], message: string}
   */
  async getBookingsByStatus(status, pageNumber = 1, pageSize = 100) {
    try {
      const data = await getBookingsByStatusAPI(status, pageNumber, pageSize);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * L·∫•y chi ti·∫øt booking theo ID
   * 
   * @param bookingId ID c·ªßa booking c·∫ßn xem
   * @returns {success: boolean, data: BookingResponseDTO, message: string}
   */
  async getBookingById(bookingId) {
    try {
      const data = await getBookingByIdAPI(bookingId);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * C·∫≠p nh·∫≠t tr·∫°ng th√°i booking
   * 
   * @param bookingId ID c·ªßa booking c·∫ßn c·∫≠p nh·∫≠t
   * @param status Status m·ªõi
   * @returns {success: boolean, data: BookingResponseDTO, message: string}
   */
  async updateBookingStatus(bookingId, status) {
    try {
      const data = await updateBookingStatusAPI(bookingId, status);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * WORKFLOW STEP 3: Staff l·∫•y m·∫´u x√©t nghi·ªám v√† nh·∫≠p t√™n b√°c sƒ© ph·ª• tr√°ch
   * 
   * @param bookingId ID c·ªßa booking c·∫ßn l·∫•y m·∫´u
   * @param sampleData Th√¥ng tin ng∆∞·ªùi l·∫•y m·∫´u v√† doctorName
   * @returns {success: boolean, data: BookingResponseDTO, message: string}
   */
  async markSampleCollected(bookingId, sampleData) {
    try {
      const data = await markSampleCollectedAPI(bookingId, sampleData);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * WORKFLOW STEP 4: Staff upload k·∫øt qu·∫£ x√©t nghi·ªám
   * 
   * @param bookingId ID c·ªßa booking c·∫ßn c·∫≠p nh·∫≠t k·∫øt qu·∫£
   * @param resultData {result, resultType, notes, resultDate}
   * @returns {success: boolean, data: BookingResponseDTO, message: string}
   */
  async uploadTestResult(bookingId, resultData) {
    try {
      const data = await uploadTestResultAPI(bookingId, resultData);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * L·∫•y k·∫øt qu·∫£ x√©t nghi·ªám c·ªßa booking
   * 
   * @param bookingId ID c·ªßa booking c·∫ßn xem k·∫øt qu·∫£
   * @returns {success: boolean, data: BookingResponseDTO, message: string}
   */
  async getTestResult(bookingId) {
    try {
      const data = await getTestResultAPI(bookingId);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * L·∫•y t·∫•t c·∫£ testing services
   * 
   * @returns {success: boolean, data: TestingServiceResponseDTO[], message: string}
   */
  async getAllTestingServices() {
    try {
      const data = await getAllTestingServicesAPI();
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * T·∫°o testing service m·ªõi
   * 
   * @param serviceData Th√¥ng tin service m·ªõi
   * @returns {success: boolean, data: TestingServiceResponseDTO, message: string}
   */
  async createTestingService(serviceData) {
    try {
      const data = await createTestingServiceAPI(serviceData);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * C·∫≠p nh·∫≠t testing service
   * 
   * @param serviceId ID c·ªßa service c·∫ßn c·∫≠p nh·∫≠t
   * @param serviceData Th√¥ng tin service m·ªõi
   * @returns {success: boolean, data: TestingServiceResponseDTO, message: string}
   */
  async updateTestingService(serviceId, serviceData) {
    try {
      const data = await updateTestingServiceAPI(serviceId, serviceData);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * X√≥a testing service
   * 
   * @param serviceId ID c·ªßa service c·∫ßn x√≥a
   * @returns {success: boolean, message: string}
   */
  async deleteTestingService(serviceId) {
    try {
      const data = await deleteTestingServiceAPI(serviceId);
      return { success: true, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * L·∫•y th·ªëng k√™ dashboard cho staff
   * 
   * @returns {success: boolean, data: DashboardStats, message: string}
   */
  async getStaffDashboardStats() {
    try {
      const data = await getStaffDashboardStatsAPI();
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  /**
   * L·∫•y booking theo kho·∫£ng th·ªùi gian
   * 
   * @param startDate Ng√†y b·∫Øt ƒë·∫ßu
   * @param endDate Ng√†y k·∫øt th√∫c
   * @returns {success: boolean, data: BookingResponseDTO[], message: string}
   */
  async getBookingsByDateRange(startDate, endDate) {
    try {
      const data = await getBookingsByDateRangeAPI(startDate, endDate);
      return { success: true, data: data.data || data.content, message: data.message };
    } catch (error) {
      const errorMessage = error.response?.data?.message || error.message;
      return { success: false, message: errorMessage };
    }
  }

  // Legacy methods for backward compatibility
  async updateTestResult(bookingId, resultData) {
    return this.uploadTestResult(bookingId, resultData);
  }

  async deliverTestResult(bookingId, resultData) {
    return this.uploadTestResult(bookingId, resultData);
  }
}

// Legacy API functions for backward compatibility
const deliverTestResultAPI = async (bookingId, resultData) => {
  try {
    const response = await instance.post(`/api/services/testing-services/bookings/${bookingId}/results`, resultData);
    console.log('Deliver test result success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Deliver test result error:', error.response?.data || error.message);
    throw error;
  }
};

// Export individual API functions for direct use
export {
  getAllBookingsAPI,
  getBookingsByStatusAPI,
  getBookingByIdAPI,
  updateBookingStatusAPI,
  markSampleCollectedAPI,
  uploadTestResultAPI,
  getTestResultAPI,
  getAllTestingServicesAPI,
  createTestingServiceAPI,
  updateTestingServiceAPI,
  deleteTestingServiceAPI,
  getStaffDashboardStatsAPI,
  getBookingsByDateRangeAPI,
  deliverTestResultAPI
};

// Export the service class instance as default
export default new StaffService();
